- 1초에 연산: 2000만번
- k in dict.keys() -> 시간 복잡도 O(1)
- nCr = n! / (n-r)! * r!
- nPr = n! / (n-r)!
- nC2 = n * (n-1) / 2
- set 안에는 list가 못 들어감.. tuple은 가능!
- zip(*matrix)는 세로 배열을 가져옴
- 파이썬에서 heapq의 default는 최소힙이다.
- 파이썬의 재귀 기본 depth는 1000이다.
- combination_with_replacement: 중복조합
- product: 중복순열
- "002" -> "2".zfill(3)
- data = dict(), data.setdefault((a, b, c, d), list())
- bin()/ 이진수 변환, oct()/ 8진수 변환, hex()/ 16진수 변환
- int(변환할 수, 변환할 형태), ex. int("0b111100", 2) - 2진수를 10진수로 변환(60)
- string find() 왼쪽부터 찾음, rfind() 오른쪽부터 찾음
- dijkstra(with heapq): O(ElogV)
    - 1. 각 정점마다 인접한 간선 모두 검사
        - 모든 간선 검사 O(E)
    - 2. 우선 순위 큐에 간선을 넣고 빼는 작업
        - O(logE)
    - E개의 간선을 넣었다 빼는 시간 복잡도 O(ElogE)
        - E는 항상 V^2보다 작으므로 logE < logV^2 = 2logV, 따라서 하나의 간선을 넣고 빼는 시간복잡도는 O(logV)
        - 전체 시간 복잡도는 O(ElogV)
- 카탈란 수열 적용: 올바른 괄호 개수 / n+2각형으로 n개의 삼각형 나누는 개수 ...
- from collections import Counter, 리스트 내에서 숫자 개수 딕셔너리 값으로 반환
- "(-2)/3"(-0.6)와 "(-2)//3"(-1)은 값이 다름. //의 경우 내림 연산을 수행함
- defaultdict(lambda: defaultdict(set))
- (1~n) nCk값 더하기: 2^n - 1